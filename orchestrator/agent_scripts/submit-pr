#!/usr/bin/env python3
"""Push branch and create a pull request. Records hook evidence."""

import json
import os
import sys

# Env vars set by the scheduler in env.sh
TASK_ID = os.environ.get("TASK_ID", "")
TASK_TITLE = os.environ.get("TASK_TITLE", "Untitled")
BASE_BRANCH = os.environ.get("BASE_BRANCH", "main")
AGENT_NAME = os.environ.get("AGENT_NAME", "unknown")
SERVER_URL = os.environ.get("OCTOPOID_SERVER_URL", "")
RESULT_FILE = os.environ.get("RESULT_FILE", "../result.json")
NOTES_FILE = os.environ.get("NOTES_FILE", "../notes.md")

# Add orchestrator to path
ORCHESTRATOR_PYTHONPATH = os.environ.get("ORCHESTRATOR_PYTHONPATH", "")
if ORCHESTRATOR_PYTHONPATH:
    sys.path.insert(0, ORCHESTRATOR_PYTHONPATH)

from pathlib import Path
from orchestrator.repo_manager import RepoManager


def main() -> int:
    worktree = Path.cwd()
    repo = RepoManager(worktree=worktree, base_branch=BASE_BRANCH)

    # Get stdout summary from last few commits for PR body
    try:
        import subprocess
        log_result = subprocess.run(
            ["git", "log", f"origin/{BASE_BRANCH}..HEAD", "--oneline"],
            cwd=worktree, capture_output=True, text=True, check=False,
        )
        commits_summary = log_result.stdout.strip() if log_result.returncode == 0 else ""
    except Exception:
        commits_summary = ""

    pr_body = (
        f"## Summary\n\n"
        f"Automated implementation for task [{TASK_ID}].\n\n"
        f"## Changes\n\n```\n{commits_summary}\n```\n\n"
        f"---\nGenerated by orchestrator agent: {AGENT_NAME}"
    )

    try:
        pr = repo.create_pr(
            title=f"[{TASK_ID}] {TASK_TITLE}",
            body=pr_body,
        )
        print(f"PR: {pr.url} (new={pr.created})")

        # Record hook evidence with server
        _record_evidence("create_pr", "passed", {
            "pr_url": pr.url,
            "pr_number": pr.number,
        })

        # Write result
        _write_result({
            "outcome": "submitted",
            "pr_url": pr.url,
            "pr_number": pr.number,
        })

        # Call the server submit endpoint directly to ensure task transitions
        # This provides immediate feedback even if the agent continues running
        _submit_to_server(pr.url, pr.number)

        return 0

    except Exception as e:
        print(f"Error creating PR: {e}", file=sys.stderr)
        _record_evidence("create_pr", "failed", {"error": str(e)})
        return 1


def _record_evidence(hook_name: str, status: str, data: dict) -> None:
    """Record hook evidence with the API server."""
    if not SERVER_URL or not TASK_ID:
        return
    try:
        import urllib.request
        url = f"{SERVER_URL}/api/v1/tasks/{TASK_ID}/hooks/{hook_name}/complete"
        payload = json.dumps({"status": status, "evidence": data}).encode()
        req = urllib.request.Request(
            url, data=payload, method="POST",
            headers={"Content-Type": "application/json"},
        )
        urllib.request.urlopen(req, timeout=10)
    except Exception as e:
        print(f"Warning: Failed to record evidence: {e}", file=sys.stderr)


def _write_result(data: dict) -> None:
    """Write result.json for the scheduler to read."""
    try:
        result_path = Path(RESULT_FILE)
        result_path.write_text(json.dumps(data, indent=2))
    except Exception as e:
        print(f"Warning: Failed to write result: {e}", file=sys.stderr)


def _submit_to_server(pr_url: str, pr_number: int) -> None:
    """Submit the task completion to the API server.

    This transitions the task from 'claimed' to 'provisional' immediately,
    without waiting for the agent process to exit.

    Args:
        pr_url: URL of the created pull request
        pr_number: PR number
    """
    if not SERVER_URL or not TASK_ID:
        return

    try:
        import urllib.request

        # Count commits
        worktree = Path.cwd()
        commits = 0
        try:
            import subprocess
            base = os.environ.get("BASE_BRANCH", "main")
            count_result = subprocess.run(
                ["git", "rev-list", "--count", f"origin/{base}..HEAD"],
                cwd=worktree, capture_output=True, text=True, check=False,
            )
            if count_result.returncode == 0:
                commits = int(count_result.stdout.strip())
        except (ValueError, subprocess.SubprocessError):
            pass

        # Read execution notes from notes.md if it exists
        notes_path = Path(NOTES_FILE)
        execution_notes = None
        if notes_path.exists():
            try:
                content = notes_path.read_text().strip()
                if content:
                    execution_notes = content
            except OSError:
                pass

        # Submit to server
        url = f"{SERVER_URL}/api/v1/tasks/{TASK_ID}/submit"
        submit_data = {
            "commits_count": commits,
            "turns_used": 0,  # Could be tracked in the future
        }
        if execution_notes:
            submit_data["execution_notes"] = execution_notes
        payload = json.dumps(submit_data).encode()

        req = urllib.request.Request(
            url, data=payload, method="POST",
            headers={"Content-Type": "application/json"},
        )
        response = urllib.request.urlopen(req, timeout=10)
        print(f"Task {TASK_ID} submitted to server (status: {response.status})")

        # Update PR info on the task
        update_url = f"{SERVER_URL}/api/v1/tasks/{TASK_ID}"
        update_payload = json.dumps({
            "pr_url": pr_url,
            "pr_number": pr_number,
        }).encode()
        update_req = urllib.request.Request(
            update_url, data=update_payload, method="PATCH",
            headers={"Content-Type": "application/json"},
        )
        urllib.request.urlopen(update_req, timeout=10)

    except Exception as e:
        print(f"Warning: Failed to submit to server: {e}", file=sys.stderr)
        # Non-fatal - the scheduler will handle it when the agent exits


if __name__ == "__main__":
    sys.exit(main())
