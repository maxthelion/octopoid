#!/usr/bin/env python3
"""Push branch and create a pull request. Records hook evidence."""

import json
import os
import sys

# Env vars set by the scheduler in env.sh
TASK_ID = os.environ.get("TASK_ID", "")
TASK_TITLE = os.environ.get("TASK_TITLE", "Untitled")
BASE_BRANCH = os.environ.get("BASE_BRANCH", "main")
AGENT_NAME = os.environ.get("AGENT_NAME", "unknown")
SERVER_URL = os.environ.get("OCTOPOID_SERVER_URL", "")
RESULT_FILE = os.environ.get("RESULT_FILE", "../result.json")

# Add orchestrator to path
ORCHESTRATOR_PYTHONPATH = os.environ.get("ORCHESTRATOR_PYTHONPATH", "")
if ORCHESTRATOR_PYTHONPATH:
    sys.path.insert(0, ORCHESTRATOR_PYTHONPATH)

from pathlib import Path
from orchestrator.repo_manager import RepoManager
from orchestrator.queue_utils import get_sdk, get_project


def should_skip_pr(task_id: str) -> tuple[bool, str | None]:
    """Check if this task should skip PR creation and merge directly.

    Returns:
        (should_skip, project_branch) where project_branch is the branch to merge to
    """
    if not task_id or not SERVER_URL:
        return (False, None)

    try:
        sdk = get_sdk()
        task = sdk.tasks.get(task_id)
        if not task:
            return (False, None)

        project_id = task.get("project_id")
        if not project_id:
            return (False, None)

        project = get_project(project_id)
        if not project:
            return (False, None)

        # Check if project has auto_accept and a branch
        if project.get("auto_accept") and project.get("branch"):
            return (True, project["branch"])

        return (False, None)
    except Exception as e:
        print(f"Warning: Failed to check project auto_accept: {e}", file=sys.stderr)
        return (False, None)


def main() -> int:
    worktree = Path.cwd()
    repo = RepoManager(worktree=worktree, base_branch=BASE_BRANCH)

    # Check if this is an auto-accept project task
    skip_pr, project_branch = should_skip_pr(TASK_ID)

    if skip_pr and project_branch:
        # Merge directly to project branch instead of creating PR
        return merge_to_project_branch(repo, project_branch)

    # Get stdout summary from last few commits for PR body
    try:
        import subprocess
        log_result = subprocess.run(
            ["git", "log", f"origin/{BASE_BRANCH}..HEAD", "--oneline"],
            cwd=worktree, capture_output=True, text=True, check=False,
        )
        commits_summary = log_result.stdout.strip() if log_result.returncode == 0 else ""
    except Exception:
        commits_summary = ""

    pr_body = (
        f"## Summary\n\n"
        f"Automated implementation for task [{TASK_ID}].\n\n"
        f"## Changes\n\n```\n{commits_summary}\n```\n\n"
        f"---\nGenerated by orchestrator agent: {AGENT_NAME}"
    )

    try:
        pr = repo.create_pr(
            title=f"[{TASK_ID}] {TASK_TITLE}",
            body=pr_body,
        )
        print(f"PR: {pr.url} (new={pr.created})")

        # Record hook evidence with server
        _record_evidence("create_pr", "passed", {
            "pr_url": pr.url,
            "pr_number": pr.number,
        })

        # Write result
        _write_result({
            "outcome": "submitted",
            "pr_url": pr.url,
            "pr_number": pr.number,
        })

        # Call the server submit endpoint directly to ensure task transitions
        # This provides immediate feedback even if the agent continues running
        _submit_to_server(pr.url, pr.number)

        return 0

    except Exception as e:
        print(f"Error creating PR: {e}", file=sys.stderr)
        _record_evidence("create_pr", "failed", {"error": str(e)})
        return 1


def _record_evidence(hook_name: str, status: str, data: dict) -> None:
    """Record hook evidence with the API server."""
    if not SERVER_URL or not TASK_ID:
        return
    try:
        import urllib.request
        url = f"{SERVER_URL}/api/v1/tasks/{TASK_ID}/hooks/{hook_name}/complete"
        payload = json.dumps({"status": status, "evidence": data}).encode()
        req = urllib.request.Request(
            url, data=payload, method="POST",
            headers={"Content-Type": "application/json"},
        )
        urllib.request.urlopen(req, timeout=10)
    except Exception as e:
        print(f"Warning: Failed to record evidence: {e}", file=sys.stderr)


def _write_result(data: dict) -> None:
    """Write result.json for the scheduler to read."""
    try:
        result_path = Path(RESULT_FILE)
        result_path.write_text(json.dumps(data, indent=2))
    except Exception as e:
        print(f"Warning: Failed to write result: {e}", file=sys.stderr)


def merge_to_project_branch(repo: RepoManager, project_branch: str) -> int:
    """Merge task commits directly to project branch (skip PR creation).

    Args:
        repo: RepoManager instance
        project_branch: Project branch to merge to

    Returns:
        Exit code (0 for success, 1 for failure)
    """
    worktree = Path.cwd()

    try:
        import subprocess

        # Get current branch (agent's task branch)
        status = repo.get_status()
        task_branch = status.branch

        print(f"Merging {task_branch} â†’ {project_branch} (auto-accept project)")

        # Fetch latest project branch
        subprocess.run(
            ["git", "fetch", "origin", project_branch],
            cwd=worktree, check=True, capture_output=True, timeout=60
        )

        # Checkout project branch
        subprocess.run(
            ["git", "checkout", project_branch],
            cwd=worktree, check=True, capture_output=True, timeout=30
        )

        # Merge task branch into project branch
        merge_result = subprocess.run(
            ["git", "merge", "--no-ff", task_branch, "-m",
             f"Merge task {TASK_ID}: {TASK_TITLE}"],
            cwd=worktree, capture_output=True, text=True, timeout=60
        )

        if merge_result.returncode != 0:
            print(f"Merge failed: {merge_result.stderr}", file=sys.stderr)
            return 1

        # Push project branch
        subprocess.run(
            ["git", "push", "origin", project_branch],
            cwd=worktree, check=True, capture_output=True, timeout=60
        )

        print(f"Successfully merged to {project_branch} and pushed")

        # Record evidence
        _record_evidence("merge_to_project_branch", "passed", {
            "project_branch": project_branch,
            "task_branch": task_branch,
        })

        # Write result (no PR for auto-accept tasks)
        _write_result({
            "outcome": "submitted",
            "project_branch": project_branch,
        })

        # Submit to server (transitions to provisional for auto-accept)
        _submit_to_server_no_pr()

        return 0

    except Exception as e:
        print(f"Error merging to project branch: {e}", file=sys.stderr)
        _record_evidence("merge_to_project_branch", "failed", {"error": str(e)})
        return 1


def _submit_to_server_no_pr() -> None:
    """Submit task without PR (for auto-accept projects)."""
    if not SERVER_URL or not TASK_ID:
        return

    try:
        import urllib.request
        import subprocess

        # Count commits
        worktree = Path.cwd()
        commits = 0
        try:
            base = os.environ.get("BASE_BRANCH", "main")
            count_result = subprocess.run(
                ["git", "rev-list", "--count", f"origin/{base}..HEAD"],
                cwd=worktree, capture_output=True, text=True, check=False,
            )
            if count_result.returncode == 0:
                commits = int(count_result.stdout.strip())
        except (ValueError, subprocess.SubprocessError):
            pass

        # Submit to server
        url = f"{SERVER_URL}/api/v1/tasks/{TASK_ID}/submit"
        payload = json.dumps({
            "commits_count": commits,
            "turns_used": 0,
        }).encode()

        req = urllib.request.Request(
            url, data=payload, method="POST",
            headers={"Content-Type": "application/json"},
        )
        response = urllib.request.urlopen(req, timeout=10)
        print(f"Task {TASK_ID} submitted to server (status: {response.status})")

    except Exception as e:
        print(f"Warning: Failed to submit to server: {e}", file=sys.stderr)


def _submit_to_server(pr_url: str, pr_number: int) -> None:
    """Submit the task completion to the API server.

    This transitions the task from 'claimed' to 'provisional' immediately,
    without waiting for the agent process to exit.

    Args:
        pr_url: URL of the created pull request
        pr_number: PR number
    """
    if not SERVER_URL or not TASK_ID:
        return

    try:
        import urllib.request

        # Count commits
        worktree = Path.cwd()
        commits = 0
        try:
            import subprocess
            base = os.environ.get("BASE_BRANCH", "main")
            count_result = subprocess.run(
                ["git", "rev-list", "--count", f"origin/{base}..HEAD"],
                cwd=worktree, capture_output=True, text=True, check=False,
            )
            if count_result.returncode == 0:
                commits = int(count_result.stdout.strip())
        except (ValueError, subprocess.SubprocessError):
            pass

        # Submit to server
        url = f"{SERVER_URL}/api/v1/tasks/{TASK_ID}/submit"
        payload = json.dumps({
            "commits_count": commits,
            "turns_used": 0,  # Could be tracked in the future
        }).encode()

        req = urllib.request.Request(
            url, data=payload, method="POST",
            headers={"Content-Type": "application/json"},
        )
        response = urllib.request.urlopen(req, timeout=10)
        print(f"Task {TASK_ID} submitted to server (status: {response.status})")

        # Update PR info on the task
        update_url = f"{SERVER_URL}/api/v1/tasks/{TASK_ID}"
        update_payload = json.dumps({
            "pr_url": pr_url,
            "pr_number": pr_number,
        }).encode()
        update_req = urllib.request.Request(
            update_url, data=update_payload, method="PATCH",
            headers={"Content-Type": "application/json"},
        )
        urllib.request.urlopen(update_req, timeout=10)

    except Exception as e:
        print(f"Warning: Failed to submit to server: {e}", file=sys.stderr)
        # Non-fatal - the scheduler will handle it when the agent exits


if __name__ == "__main__":
    sys.exit(main())
