"""Implementer role - claims tasks and implements features."""

from ..config import is_db_enabled
from ..git_utils import (
    create_feature_branch,
    create_pull_request,
    get_commit_count,
    get_head_ref,
    has_uncommitted_changes,
)
from ..queue_utils import (
    claim_task,
    complete_task,
    fail_task,
    submit_completion,
)
from .base import BaseRole, main_entry


class ImplementerRole(BaseRole):
    """Implementer that claims tasks and creates pull requests."""

    def run(self) -> int:
        """Claim a task and implement it.

        Returns:
            Exit code (0 for success)
        """
        # Note: Backpressure is now checked by the scheduler before spawning.
        # This avoids wasting resources on agent startup when blocked.

        # Try to claim a task
        task = claim_task(role_filter="implement", agent_name=self.agent_name)
        if not task:
            self.log("No tasks available to claim")
            return 0

        task_id = task["id"]
        task_title = task["title"]
        base_branch = task.get("branch", "main")
        task_path = task["path"]

        self.log(f"Claimed task {task_id}: {task_title}")

        try:
            # Create feature branch
            branch_name = create_feature_branch(self.worktree, task_id, base_branch)
            self.log(f"Created branch: {branch_name}")

            # Snapshot HEAD before implementation so we count only NEW commits
            head_before = get_head_ref(self.worktree)
            self.debug_log(f"HEAD before implementation: {head_before[:8]}")

            # Build prompt for Claude
            instructions = self.read_instructions()
            task_content = task.get("content", "")

            prompt = f"""You are an implementer agent working on this task.

{instructions}

## Task Details

{task_content}

## Instructions

1. Analyze the codebase to understand the context
2. Implement the changes required by the task
3. Write or update tests as needed
4. Commit your changes with clear messages
5. When done, summarize what you implemented

Use the /implement skill for guidance on implementation best practices.

Remember:
- Follow existing code patterns
- Keep changes focused on the task
- Test your changes
- Create atomic, well-described commits
"""

            # Invoke Claude with implementation tools
            allowed_tools = [
                "Read",
                "Write",
                "Edit",
                "Glob",
                "Grep",
                "Bash",
                "Skill",
            ]

            exit_code, stdout, stderr = self.invoke_claude(
                prompt,
                allowed_tools=allowed_tools,
                max_turns=50,  # Allow more turns for implementation
            )

            # Count commits made during this session only
            if head_before:
                commits_made = get_commit_count(self.worktree, since_ref=head_before)
            else:
                commits_made = get_commit_count(self.worktree)
            self.debug_log(f"Commits made this session: {commits_made}")

            if exit_code != 0:
                self.log(f"Implementation failed: {stderr}")
                fail_task(task_path, f"Claude invocation failed with exit code {exit_code}\n{stderr}")
                return exit_code

            # Check if any changes were made
            if not has_uncommitted_changes(self.worktree):
                # Changes may have been committed by Claude
                pass

            # Try to create PR
            pr_url = None
            try:
                pr_body = f"""## Summary

Automated implementation for task [{task_id}].

## Task

{task_title}

## Changes

{stdout[-2000:] if len(stdout) > 2000 else stdout}

---
Generated by orchestrator agent: {self.agent_name}
"""
                pr_url = create_pull_request(
                    self.worktree,
                    branch_name,
                    base_branch,
                    f"[{task_id}] {task_title}",
                    pr_body,
                )
                self.log(f"Created PR: {pr_url}")

            except Exception as e:
                self.log(f"Failed to create PR: {e}")
                # Continue to completion even if PR creation fails

            # Complete the task - use submit_completion in DB mode for validation
            result_msg = f"PR created: {pr_url}" if pr_url else "Implementation complete (PR creation failed)"

            if is_db_enabled():
                # Submit for validation - validator will check commits
                submit_completion(
                    task_path,
                    commits_count=commits_made,
                    turns_used=50,  # TODO: Track actual turns used
                )
                self.log(f"Submitted for validation ({commits_made} commits)")
            else:
                # Direct completion in file-based mode
                complete_task(task_path, result_msg)

            return 0

        except Exception as e:
            self.log(f"Task failed: {e}")
            fail_task(task_path, str(e))
            return 1


def main():
    main_entry(ImplementerRole)


if __name__ == "__main__":
    main()
