"""Implementer role - claims tasks and implements features."""

import sys

from ..git_utils import (
    commit_changes,
    create_feature_branch,
    create_pull_request,
    has_uncommitted_changes,
)
from ..queue_utils import can_claim_task, claim_task, complete_task, fail_task
from .base import BaseRole, main_entry


class ImplementerRole(BaseRole):
    """Implementer that claims tasks and creates pull requests."""

    def run(self) -> int:
        """Claim a task and implement it.

        Returns:
            Exit code (0 for success)
        """
        # Check backpressure
        can_claim, reason = can_claim_task()
        if not can_claim:
            self.log(f"Cannot claim task: {reason}")
            return 0  # Not an error, just nothing to do

        # Try to claim a task
        task = claim_task(role_filter="implement", agent_name=self.agent_name)
        if not task:
            self.log("No tasks available to claim")
            return 0

        task_id = task["id"]
        task_title = task["title"]
        base_branch = task.get("branch", "main")
        task_path = task["path"]

        self.log(f"Claimed task {task_id}: {task_title}")

        try:
            # Create feature branch
            branch_name = create_feature_branch(self.worktree, task_id, base_branch)
            self.log(f"Created branch: {branch_name}")

            # Build prompt for Claude
            instructions = self.read_instructions()
            task_content = task.get("content", "")

            prompt = f"""You are an implementer agent working on this task.

{instructions}

## Task Details

{task_content}

## Instructions

1. Analyze the codebase to understand the context
2. Implement the changes required by the task
3. Write or update tests as needed
4. Commit your changes with clear messages
5. When done, summarize what you implemented

Use the /implement skill for guidance on implementation best practices.

Remember:
- Follow existing code patterns
- Keep changes focused on the task
- Test your changes
- Create atomic, well-described commits
"""

            # Invoke Claude with implementation tools
            allowed_tools = [
                "Read",
                "Write",
                "Edit",
                "Glob",
                "Grep",
                "Bash",
                "Skill",
            ]

            exit_code, stdout, stderr = self.invoke_claude(
                prompt,
                allowed_tools=allowed_tools,
                max_turns=50,  # Allow more turns for implementation
            )

            if exit_code != 0:
                self.log(f"Implementation failed: {stderr}")
                fail_task(task_path, f"Claude invocation failed with exit code {exit_code}\n{stderr}")
                return exit_code

            # Check if any changes were made
            if not has_uncommitted_changes(self.worktree):
                # Changes may have been committed by Claude
                pass

            # Try to create PR
            try:
                pr_body = f"""## Summary

Automated implementation for task [{task_id}].

## Task

{task_title}

## Changes

{stdout[-2000:] if len(stdout) > 2000 else stdout}

---
Generated by orchestrator agent: {self.agent_name}
"""
                pr_url = create_pull_request(
                    self.worktree,
                    branch_name,
                    base_branch,
                    f"[{task_id}] {task_title}",
                    pr_body,
                )
                self.log(f"Created PR: {pr_url}")
                complete_task(task_path, f"PR created: {pr_url}")

            except Exception as e:
                self.log(f"Failed to create PR: {e}")
                # Task is complete even if PR creation fails
                # The code is on a branch that can be manually pushed
                complete_task(task_path, f"Implementation complete but PR creation failed: {e}")

            return 0

        except Exception as e:
            self.log(f"Task failed: {e}")
            fail_task(task_path, str(e))
            return 1


def main():
    main_entry(ImplementerRole)


if __name__ == "__main__":
    main()
